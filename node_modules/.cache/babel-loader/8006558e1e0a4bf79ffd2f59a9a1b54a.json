{"ast":null,"code":"var _jsxFileName = \"/Users/briancoburn/WebstormProjects/reactive_robot/src/App.js\";\nimport React, { useState, useEffect } from 'react';\nimport './App.css';\nimport * as ds from \"./DataService\";\nimport * as rr from './ReactiveRobot';\nimport * as ev from './Events';\nimport Component1 from \"./Component1\";\nimport Component2 from \"./Component2\";\n\nfunction App() {\n  const [hasRequestedData, setHasRequestedData] = useState(false); //if you're mounting/unmounting components, you can cache their data here\n  //do not put this in state, or you will rerender everything when it changes\n\n  let globalData = {\n    component1LatestValue: '',\n    component2LatestValue: ''\n  };\n  console.log('App==>rendering:');\n  useEffect(() => {\n    rr.addObserver(onEvent);\n  }, []);\n\n  function onEvent(event) {\n    switch (event.type) {\n      case ev.APP_TEST:\n        console.log('App==>got TEST_APP event');\n    }\n  }\n\n  function getData() {\n    console.log('App==>getData()');\n    ds.getData();\n    setHasRequestedData(true);\n  }\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"App\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 37,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"h4\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 38,\n      columnNumber: 7\n    }\n  }, \"Reactive Robot\"), /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 39,\n      columnNumber: 7\n    }\n  }, \"State management framework\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 40,\n      columnNumber: 7\n    }\n  }, \"ReactiveRobot is a lean and mean react state management framework that promotes a high level of decoupling, granular control of rendering, and components that react to events. It is intended to be a simple and highly performant alternative to popular state management systems such as Redux, mobx, useContext, etc.\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 45,\n      columnNumber: 7\n    }\n  }, \"You can examine the ReactiveRobot object yourself. It is quite simple. It has a list of observers, methods to add and remove them, and a trigger method, which will call the registered observer functions with any event that comes thru. There are not strict requirements for how to use ReactiveRobot, but this example shows you some easy ways to get going. I'll call it best practices until I come up with or am made aware of better ones.\"), /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 51,\n      columnNumber: 7\n    }\n  }, \"What Do We Have Here?\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 52,\n      columnNumber: 7\n    }\n  }, \"This application was made with create-react-app. You might want to do that too. Aside from the files that are generated by create-react-app, these have been added to create a demonstration of how to use ReactiveRobot:\"), /*#__PURE__*/React.createElement(\"ul\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 56,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 57,\n      columnNumber: 9\n    }\n  }, \"ReactiveRobot\"), /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 58,\n      columnNumber: 9\n    }\n  }, \"Events\"), /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 59,\n      columnNumber: 9\n    }\n  }, \"DataService\"), /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 60,\n      columnNumber: 9\n    }\n  }, \"Component1\"), /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 61,\n      columnNumber: 9\n    }\n  }, \"Component2\")), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 63,\n      columnNumber: 7\n    }\n  }, \"ReactiveRobot itself, which adds/removes observers, and triggers events to them. Events is not required, but is a convenient way to store string constants for events that will give you code-completion in your IDE. DataService is not required, but would be where data comes from. Here I have it tightly coupled to App, but it could both observe requests for data, and send it off as events to interested components once it has been received (or mocked). Think of it as an object that will return events containing data.\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 70,\n      columnNumber: 7\n    }\n  }, \"Because everything is an event in this framework there are no issues with async. You can use callbacks, promises, async await, sockets, mock data - ReactiveRobot don't care, it just sends the data as an event when it gets it. Of course you are responsible for pushing your observation of events as far down the component tree as possible. Components that want that data consume it, useState and rerender. Components that didn't register for that data never get that event and do not update, unless you mistakenly or purposely cause a rerender in one of their ancestors. This is the main purpose of this framework - to control unnecessary re-rendering. If you have developed large-scale react apps, you will recognize this is highly desirable for performance reasons.\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 80,\n      columnNumber: 7\n    }\n  }, \"Here we have two components, each which listens for its own custom event. When you click GET DATA, App calls the getData function on DataService, which in this case sets an interval and starts generating mock data which will randomly send update events to APP, COMPONENT1 and COMPONENT2. Logging has been added to allow you to observe what is rerendering on what events.\"), /*#__PURE__*/React.createElement(\"button\", {\n    disabled: hasRequestedData,\n    onClick: () => {\n      getData();\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 86,\n      columnNumber: 7\n    }\n  }, \"GET DATA\"), /*#__PURE__*/React.createElement(Component1, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 87,\n      columnNumber: 7\n    }\n  }), /*#__PURE__*/React.createElement(Component2, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 88,\n      columnNumber: 7\n    }\n  }), /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 89,\n      columnNumber: 7\n    }\n  }, \"Digging Deeper\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 90,\n      columnNumber: 7\n    }\n  }, \"Obviously, this is not a full-scale application. And there are some issues that will come up that aren't addressed in this example. If you don't have global state and you've pushed it all the way down the tree to your leaf components, how do you maintain their state when they mount, unmount and remount again?\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 95,\n      columnNumber: 7\n    }\n  }, \"I see two simple ways to do this. First, maintain data that you might need again in a globaldata object (which is not state, and should never cause a rerender). I would put that object in App. App can listen for the event required to cache the data. In that case, you are duplicating your observation for the event in App and in the consuming Component. This is more boilerplate than I would like, but it is solid, and allows a great deal of flexibility if lots of different components that mount and unmount are sharing data. An alternative would be to use the useEffect unmount callback to send an event which App could consume that would cache the data when the component unmounted and provide as props when the component mounted again. You could do all of this with events rather than using props at all, but you might find such extreme decoupling demands more boilerplate than you want to write. With purity comes a price.\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 107,\n      columnNumber: 7\n    }\n  }, \"Just remember, ReactiveRobot is short on rules and long on flexibility. You decide where you want to store data and initiate things like api calls. Obviously you could do an api call from a component when it mounts with useEffect, but you could also get data on the app level before the component mounts. When the component mounts, it sends an event requesting the data, the data is returned in a subsequent event, and the component does not know or care where that data came from. This gives you huge flexibility for mocking, testing and scaling.\"), /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 114,\n      columnNumber: 7\n    }\n  }, \"Comparisons with Redux\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 115,\n      columnNumber: 7\n    }\n  }, \"Like Redux, ReactiveRobot has a specific way to update things. Send an event. Unlike Redux, there is no enforcement of this in the code, it is up to you to understand it and use it correctly. Also, unlike Redux, there is no embrace of immutability here. Use immutable objects if you like, ReactiveRobot don't care. I'd say the main purpose of code is to mutate data, don't be afraid to. And unlike Redux where everybody gets access to a global Store, there is no such concept in ReactiveRobot. Components should not know or care where their data comes from.\"));\n}\n\nexport default App;","map":{"version":3,"sources":["/Users/briancoburn/WebstormProjects/reactive_robot/src/App.js"],"names":["React","useState","useEffect","ds","rr","ev","Component1","Component2","App","hasRequestedData","setHasRequestedData","globalData","component1LatestValue","component2LatestValue","console","log","addObserver","onEvent","event","type","APP_TEST","getData"],"mappings":"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","sourcesContent":["import React, {useState, useEffect} from 'react'\nimport './App.css'\nimport * as ds from \"./DataService\"\nimport * as rr from './ReactiveRobot'\nimport * as ev from './Events'\nimport Component1 from \"./Component1\"\nimport Component2 from \"./Component2\"\n\nfunction App() {\n  const [hasRequestedData, setHasRequestedData] = useState(false)\n  //if you're mounting/unmounting components, you can cache their data here\n  //do not put this in state, or you will rerender everything when it changes\n  let globalData = {\n    component1LatestValue:'',\n    component2LatestValue:'',\n  }\n\n  console.log('App==>rendering:')\n\n  useEffect(()=>{\n    rr.addObserver(onEvent)\n  },[])\n\n  function onEvent(event){\n    switch (event.type){\n      case ev.APP_TEST:\n        console.log('App==>got TEST_APP event')\n    }\n  }\n  function getData(){\n    console.log('App==>getData()')\n    ds.getData()\n    setHasRequestedData(true)\n  }\n\n  return (\n    <div className=\"App\">\n      <h4>Reactive Robot</h4>\n      <h5>State management framework</h5>\n      <p>\n        ReactiveRobot is a lean and mean react state management framework that promotes a high level of decoupling,\n        granular control of rendering, and components that react to events. It is intended to be a simple and highly\n        performant alternative to popular state management systems such as Redux, mobx, useContext, etc.\n      </p>\n      <p>\n        You can examine the ReactiveRobot object yourself. It is quite simple. It has a list of observers, methods to\n        add and remove them, and a trigger method, which will call the registered observer functions with any event that\n        comes thru. There are not strict requirements for how to use ReactiveRobot, but this example shows you some easy\n        ways to get going. I'll call it best practices until I come up with or am made aware of better ones.\n      </p>\n      <h5>What Do We Have Here?</h5>\n      <p>\n        This application was made with create-react-app. You might want to do that too. Aside from the files that are generated\n        by create-react-app, these have been added to create a demonstration of how to use ReactiveRobot:\n      </p>\n      <ul>\n        <li>ReactiveRobot</li>\n        <li>Events</li>\n        <li>DataService</li>\n        <li>Component1</li>\n        <li>Component2</li>\n      </ul>\n      <p>\n        ReactiveRobot itself, which adds/removes observers, and triggers events to them. Events is not required,\n        but is a convenient way to store string constants for events that will give you code-completion in your IDE.\n        DataService is not required, but would be where data comes from. Here I have it tightly coupled to App,\n        but it could both observe requests for data, and send it off as events to interested components once it\n        has been received (or mocked). Think of it as an object that will return events containing data.\n      </p>\n      <p>\n        Because everything is an event in this framework there are no issues with async. You can use callbacks,\n        promises, async await, sockets, mock data - ReactiveRobot don't care, it just sends the data as an event\n        when it gets it. Of course you are responsible for pushing your observation of events as far down the\n        component tree as possible. Components that want that data consume it, useState and rerender.\n        Components that didn't register for that data never get that event and do not update, unless you mistakenly\n        or purposely cause a rerender in one of their ancestors. This is the main purpose of this framework - to\n        control unnecessary re-rendering. If you have developed large-scale react apps, you will recognize this is\n        highly desirable for performance reasons.\n      </p>\n      <p>\n        Here we have two components, each which listens for its own custom event. When you click GET DATA,\n        App calls the getData function on DataService, which in this case sets an interval and starts\n        generating mock data which will randomly send update events to APP, COMPONENT1 and COMPONENT2.\n        Logging has been added to allow you to observe what is rerendering on what events.\n      </p>\n      <button disabled={hasRequestedData} onClick={()=>{getData()}}>GET DATA</button>\n      <Component1/>\n      <Component2/>\n      <h5>Digging Deeper</h5>\n      <p>\n        Obviously, this is not a full-scale application. And there are some issues that will come up that aren't addressed\n        in this example. If you don't have global state and you've pushed it all the way down the tree to your leaf\n        components, how do you maintain their state when they mount, unmount and remount again?\n      </p>\n      <p>\n        I see two simple ways to do this. First, maintain data that you might need again in a globaldata object\n        (which is not state, and should never cause a rerender). I would put that object in App. App can listen\n        for the event required to cache the data. In that case, you are duplicating your observation for the event\n        in App and in the consuming Component. This is more boilerplate than I would like, but it is solid, and\n        allows a great deal of flexibility if lots of different components that mount and unmount are sharing data.\n        An alternative would be to use the useEffect unmount callback to send an event which App could consume that\n        would cache the data when the component unmounted and provide as props when the component mounted again.\n        You could do all of this with events rather than using props at all, but you might find such extreme\n        decoupling demands more boilerplate than you want to write. With purity comes a price.\n\n      </p>\n      <p>\n        Just remember, ReactiveRobot is short on rules and long on flexibility. You decide where you want to store\n        data and initiate things like api calls. Obviously you could do an api call from a component when it mounts with\n        useEffect, but you could also get data on the app level before the component mounts. When the component mounts,\n        it sends an event requesting the data, the data is returned in a subsequent event, and the component does not\n        know or care where that data came from. This gives you huge flexibility for mocking, testing and scaling.\n      </p>\n      <h5>Comparisons with Redux</h5>\n      <p>\n        Like Redux, ReactiveRobot has a specific way to update things. Send an event. Unlike Redux, there is no\n        enforcement of this in the code, it is up to you to understand it and use it correctly. Also, unlike Redux,\n        there is no embrace of immutability here. Use immutable objects if you like, ReactiveRobot don't care.\n        I'd say the main purpose of code is to mutate data, don't be afraid to. And unlike Redux where everybody\n        gets access to a global Store, there is no such concept in ReactiveRobot. Components should not know or care\n        where their data comes from.\n      </p>\n     \n    </div>\n  );\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}