{"ast":null,"code":"var _jsxFileName = \"/Users/briancoburn/WebstormProjects/reactive_robot/src/App.js\";\nimport React, { useState, useEffect } from 'react';\nimport './App.css';\nimport * as ds from \"./DataService\";\nimport * as rr from './ReactiveRobot';\nimport * as ev from './Events';\nimport UIControls from \"./UIControls\";\nimport Component1 from \"./Component1\";\nimport Component2 from \"./Component2\";\n\nfunction App() {\n  const [numItems, setNumItems] = useState(0); // const [updateDelta, setUpdateDelta] = useState(1000)\n  //if you're mounting/unmounting components, you can cache their data here\n  //do not put this in state, or you will rerender everything when it changes\n  // let gData = {\n  //   component1LatestValue:'',\n  //   component2LatestValue:'',\n  // }\n  //console.log('App==>rendering==>rr.gData:',rr.gData)\n  //rr.gData = 'hello';//{...rr.gData, component1:{name:'component1'}}\n\n  console.log('App==>rendering==>rr.gData:', rr.gData);\n  useEffect(() => {\n    // rr.gData.component1 = {name:'Component1', createdAt: Date.now()}\n    // rr.gData.component2 = {name:'Component2', createdAt: Date.now()}\n    console.log('App==>adding myself as an observer');\n    rr.addObserver(onEvent);\n  }, []);\n\n  function onEvent(event) {\n    //console.log('App==>event:', event)\n    switch (event.type) {\n      case ev.INITIALIZE_COMPONENTS:\n        setNumItems(event.data.numItems);\n        break;\n      // case ev.GET_DATA:\n      //   console.log('App==>got GET_DATA event')\n      //   ds.getData()\n      //   break\n      // case ev.COMPONENT_UPDATE_GET:\n      //   console.log('App==>got COMPONENT_UPDATE_GET event')\n      //   ds.getData(event.data.name)\n    }\n  } ///let numComponents = 3000\n\n\n  let components = [];\n\n  for (let i = 0; i < numItems; i += 1) {\n    components.push( /*#__PURE__*/React.createElement(Component1, {\n      key: i,\n      name: 'Component' + i,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 50,\n        columnNumber: 21\n      }\n    }));\n  }\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"App\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 55,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"h4\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 56,\n      columnNumber: 7\n    }\n  }, \"Reactive Robot\"), /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 57,\n      columnNumber: 7\n    }\n  }, \"State Management Framework For React\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 58,\n      columnNumber: 7\n    }\n  }, \"ReactiveRobot is a lean and mean react state management framework that promotes a high level of decoupling, granular control of rendering, and components that react to events. It is intended to be a simple, unopinionated, and highly performant alternative to popular state management systems such as Redux, mobx, useContext, etc. It is also sort of like rxjs without operators - a way of producing and consuming a stream of data in a network of decoupled objects using a pub/sub mechanism.\"), /*#__PURE__*/React.createElement(\"span\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 65,\n      columnNumber: 7\n    }\n  }, \"Reactive Robot has two main rules:\"), /*#__PURE__*/React.createElement(\"ul\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 66,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 68,\n      columnNumber: 9\n    }\n  }, \"-do not observe or react directly to changes in global state\"), /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 69,\n      columnNumber: 9\n    }\n  }, \"-use only events to cause ui updates\")), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 71,\n      columnNumber: 7\n    }\n  }, \"If you follow these rules, Reactive Robot will allow you to create an application which is highly decoupled, scalable and performant. Because everything is an event, you have complete control over rendering and asynchronous operations.\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 76,\n      columnNumber: 7\n    }\n  }, \"You can examine the ReactiveRobot object yourself, ReactiveRobot.js. It is quite simple. It has a list of observers, methods to add and remove them, and a next method, which will call the registered observer functions with any event that comes thru. There is also a globalData, or gData property on the Reactive Robot object which can act as a cache for global data that you might want to reuse when loading/unloading views. There are not strict requirements for how to use ReactiveRobot, other than that you should use events to communicate changes in data, and those changes should be received by a registered onEvent function in components that want that data. This example shows you some easy ways to get going. I'll call it best practices until I come up with or am made aware of better ones.\"), /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 86,\n      columnNumber: 7\n    }\n  }, \"Example Application\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 87,\n      columnNumber: 7\n    }\n  }, \"This application was made with create-react-app. Aside from the files that are generated by create-react-app, these have been added to make a demonstration of how to use ReactiveRobot:\"), /*#__PURE__*/React.createElement(\"ul\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 91,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 92,\n      columnNumber: 9\n    }\n  }, \"ReactiveRobot.js\"), /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 93,\n      columnNumber: 9\n    }\n  }, \"Events.js\"), /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 94,\n      columnNumber: 9\n    }\n  }, \"DataService.js\"), /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 95,\n      columnNumber: 9\n    }\n  }, \"UIControls.js\"), /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 96,\n      columnNumber: 9\n    }\n  }, \"Component1.js\")), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 98,\n      columnNumber: 7\n    }\n  }, \"ReactiveRobot.js itself, which adds/removes observers, and sends events to them and keeps a data cache. Events.js is not required, but is a convenient way to store string constants for events that will give you code-completion in your IDE. Component1 is an example lower-level component that needs realtime data updates. Each Component1 will observe the COMPONENT_UPDATE_RECEIVED event, and check if the name matches its own. If so, it updates, and nobody else does. DataService is included to simulate receiving of async data, like if you were getting updates over a socket that could be for any component. In this simulation it sends an update to a random component, at an interval that was specified in UIControls.\"), /*#__PURE__*/React.createElement(\"div\", {\n    className: 'ExampleSection',\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 109,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 110,\n      columnNumber: 9\n    }\n  }, \"Example Application\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 111,\n      columnNumber: 9\n    }\n  }, \"Set the number of components you want to create and the rate at which you want updates to occur. By setting a very large number of components, and/or a very short update delta, you can test performance, or kill your browser.\"), /*#__PURE__*/React.createElement(UIControls, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 116,\n      columnNumber: 9\n    }\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    className: 'ComponentsContainer',\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 117,\n      columnNumber: 9\n    }\n  }, components)), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 122,\n      columnNumber: 7\n    }\n  }, \"Because everything is an event in this framework there are no issues with async. You can use callbacks, promises, async await, sockets, mock data - ReactiveRobot don't care, it just sends the data as an event when it gets it and the interested parties consume it. Of course you are responsible for pushing your observation of events to the appropriate level - usually as far down the component tree as possible. Components that want that data consume it, cache it, or useState and rerender. Components that didn't register for that data never process that event and do not update, unless you mistakenly or purposely cause a rerender in one of their ancestors. This is the main purpose of this framework - to control unnecessary re-rendering. If you have developed large-scale react apps, you will recognize this is highly desirable for performance reasons.\"), /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 134,\n      columnNumber: 7\n    }\n  }, \"Digging Deeper\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 135,\n      columnNumber: 7\n    }\n  }, \"Obviously, this is not a full-scale application. And there are some issues that will come up that aren't addressed in this example. If you don't have global state and you've pushed it all the way down the component tree to your leaf components, how do you maintain their state when they mount, unmount and remount again?\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 140,\n      columnNumber: 7\n    }\n  }, \"Reactive Robot has a property called gData. Because all producers and consumers of events have access to this, you can use it to store persistent global data for managing components loading and unloading. For instance in the example above, let's say you were mounting and unmounting all of your Component1 instances. You could keep the last value for dynamic message field on that object, and when you reload a component, you could check if that value is on rr.gData, then show the red border indicating that that item had been updated previously.\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 147,\n      columnNumber: 7\n    }\n  }, \"Just remember, ReactiveRobot is short on rules and long on flexibility. You decide where you want to store data and initiate things like api calls. Obviously you could do an api call from a component when it mounts with useEffect, but here you have more options. You send an event. Your component doesn't know anything about any API. You control what data it gets back from that event. Maybe call the API the first time, then just reload cached data from rr.gData. Maybe you get all the data when the app loads, and just respond to events as needed, or maybe you mock everything because the API isn't available yet or you're testing. With Reactive Robot, it's all the same.\"), /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 156,\n      columnNumber: 7\n    }\n  }, \"Comparisons with Redux\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 157,\n      columnNumber: 7\n    }\n  }, \"Like Redux, ReactiveRobot has a specific way rerender in response to changes in state. Send an event. Unlike Redux, there is no enforcement of how you make updates. You can decouple everything with a model that only responds to events, or stick everything on gData. Also, unlike Redux, there is no embrace of immutability here. Use immutable objects if you like, ReactiveRobot don't care. I'd say the main purpose of code is to mutate data - so don't be afraid to. And unlike Redux where everybody gets access to a global Store, this is not a requirement in Reactive Robot. If you have global data that needs to be cached, you have the gData object as a convenience.\"), /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 165,\n      columnNumber: 7\n    }\n  }, \"Observations On Observing and Listening\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 166,\n      columnNumber: 7\n    }\n  }, \"Why are we using observers here instead of listeners? Because the visual metaphor is trendy right now. But seriously, the audio metaphor is the same. You can be observing events or listening, same thing. Most of your basic intros to rx based reactive systems will start teaching you about observables with the metaphor of listening to mouse activity and thinking about it as a stream of data using listeners, aka observables. Because there is a similarity between ReactiveRobot and rxjs, I've used \\\"next\\\" as the method name to indicate there is another event in the stream. I could have used \\\"trigger\\\" but that seemed so...jQuery. We want to stay current, but recognize these issues have a long history of multiple solutions. I am just trying to add another solution that has worked well for me, scales easily, and encourages optimal performance with react.\"));\n}\n\nexport default App;","map":{"version":3,"sources":["/Users/briancoburn/WebstormProjects/reactive_robot/src/App.js"],"names":["React","useState","useEffect","ds","rr","ev","UIControls","Component1","Component2","App","numItems","setNumItems","console","log","gData","addObserver","onEvent","event","type","INITIALIZE_COMPONENTS","data","components","i","push"],"mappings":"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","sourcesContent":["import React, {useState, useEffect} from 'react'\nimport './App.css'\nimport * as ds from \"./DataService\"\nimport  * as rr from './ReactiveRobot'\nimport * as ev from './Events'\nimport UIControls from \"./UIControls\"\nimport Component1 from \"./Component1\"\nimport Component2 from \"./Component2\"\n\nfunction App() {\n  const [numItems, setNumItems] = useState(0)\n  // const [updateDelta, setUpdateDelta] = useState(1000)\n  //if you're mounting/unmounting components, you can cache their data here\n  //do not put this in state, or you will rerender everything when it changes\n  // let gData = {\n  //   component1LatestValue:'',\n  //   component2LatestValue:'',\n  // }\n  //console.log('App==>rendering==>rr.gData:',rr.gData)\n  //rr.gData = 'hello';//{...rr.gData, component1:{name:'component1'}}\n\n  console.log('App==>rendering==>rr.gData:',rr.gData)\n\n  useEffect(()=>{\n    // rr.gData.component1 = {name:'Component1', createdAt: Date.now()}\n    // rr.gData.component2 = {name:'Component2', createdAt: Date.now()}\n    console.log('App==>adding myself as an observer')\n    rr.addObserver(onEvent)\n  },[])\n\n  function onEvent(event){\n    //console.log('App==>event:', event)\n    switch (event.type){\n      case ev.INITIALIZE_COMPONENTS:\n        setNumItems(event.data.numItems)\n        break\n      // case ev.GET_DATA:\n      //   console.log('App==>got GET_DATA event')\n      //   ds.getData()\n      //   break\n      // case ev.COMPONENT_UPDATE_GET:\n      //   console.log('App==>got COMPONENT_UPDATE_GET event')\n      //   ds.getData(event.data.name)\n    }\n  }\n\n  ///let numComponents = 3000\n  let components = []\n  for(let i=0;i<numItems;i+=1){\n    components.push(<Component1 key={i} name={'Component'+i}></Component1>)\n  }\n\n\n  return (\n    <div className=\"App\">\n      <h4>Reactive Robot</h4>\n      <h5>State Management Framework For React</h5>\n      <p>\n        ReactiveRobot is a lean and mean react state management framework that promotes a high level of decoupling,\n        granular control of rendering, and components that react to events. It is intended to be a simple, unopinionated,\n        and highly performant alternative to popular state management systems such as Redux, mobx, useContext, etc. It is also\n        sort of like rxjs without operators - a way of producing and consuming a stream of data in a network of decoupled objects\n        using a pub/sub mechanism.\n      </p>\n      <span>Reactive Robot has two main rules:</span>\n      <ul>\n\n        <li>-do not observe or react directly to changes in global state</li>\n        <li>-use only events to cause ui updates</li>\n      </ul>\n      <p>\n        If you follow these rules, Reactive Robot will allow you to create an application which is highly decoupled,\n        scalable and performant. Because everything is an event, you have complete control over rendering and\n        asynchronous operations.\n      </p>\n      <p>\n        You can examine the ReactiveRobot object yourself, ReactiveRobot.js. It is quite simple. It has a list of observers,\n        methods to add and remove them, and a next method, which will call the registered observer functions with any event\n        that comes thru. There is also a globalData, or gData property on the Reactive Robot object which can act as a cache\n        for global data that you might want to reuse when loading/unloading views.\n        There are not strict requirements for how to use ReactiveRobot, other than that you should use events\n        to communicate changes in data, and those changes should be received by a registered onEvent function in components\n        that want that data. This example shows you some easy ways to get going. I'll call it best practices until I come\n        up with or am made aware of better ones.\n      </p>\n      <h5>Example Application</h5>\n      <p>\n        This application was made with create-react-app. Aside from the files that are generated\n        by create-react-app, these have been added to make a demonstration of how to use ReactiveRobot:\n      </p>\n      <ul>\n        <li>ReactiveRobot.js</li>\n        <li>Events.js</li>\n        <li>DataService.js</li>\n        <li>UIControls.js</li>\n        <li>Component1.js</li>\n      </ul>\n      <p>\n        ReactiveRobot.js itself, which adds/removes observers, and sends events to them and keeps a data cache.\n        Events.js is not required, but is a convenient way to store string constants for events that will give you\n        code-completion in your IDE. Component1 is an example lower-level component that needs realtime data updates.\n        Each Component1 will observe the COMPONENT_UPDATE_RECEIVED event, and check if the name matches its own. If so,\n        it updates, and nobody else does. DataService is included to simulate receiving of async data, like if you were\n        getting updates over a socket that could be for any component. In this simulation it sends an update to a\n        random component, at an interval that was specified in UIControls.\n\n      </p>\n\n      <div className={'ExampleSection'}>\n        <h5>Example Application</h5>\n        <p>\n          Set the number of components you want to create and the rate at which you want updates to occur. By setting\n          a very large number of components, and/or a very short update delta, you can test performance, or kill your browser.\n\n        </p>\n        <UIControls/>\n        <div className={'ComponentsContainer'}>\n          {components}\n        </div>\n\n      </div>\n      <p>\n        Because everything is an event in this framework there are no issues with async. You can use callbacks,\n        promises, async await, sockets, mock data - ReactiveRobot don't care, it just sends the data as an event\n        when it gets it and the interested parties consume it. Of course you are responsible for pushing your\n        observation of events to the appropriate level - usually as far down the component tree as possible.\n        Components that want that data consume it, cache it, or useState and rerender. Components that didn't\n        register for that data never process that event and do not update, unless you mistakenly or purposely\n        cause a rerender in one of their ancestors. This is the main purpose of this framework - to control\n        unnecessary re-rendering. If you have developed large-scale react apps, you will recognize this is\n        highly desirable for performance reasons.\n      </p>\n\n      <h5>Digging Deeper</h5>\n      <p>\n        Obviously, this is not a full-scale application. And there are some issues that will come up that aren't addressed\n        in this example. If you don't have global state and you've pushed it all the way down the component tree to your leaf\n        components, how do you maintain their state when they mount, unmount and remount again?\n      </p>\n      <p>\n        Reactive Robot has a property called gData. Because all producers and consumers of events have access to this,\n        you can use it to store persistent global data for managing components loading and unloading. For instance in the\n        example above, let's say you were mounting and unmounting all of your Component1 instances. You could keep the\n        last value for dynamic message field on that object, and when you reload a component, you could check if that value\n        is on rr.gData, then show the red border indicating that that item had been updated previously.\n      </p>\n      <p>\n        Just remember, ReactiveRobot is short on rules and long on flexibility. You decide where you want to store\n        data and initiate things like api calls. Obviously you could do an api call from a component when it mounts with\n        useEffect, but here you have more options. You send an event. Your component doesn't know anything about any\n        API. You control what data it gets back from that event. Maybe call the API the first time, then just reload\n        cached data from rr.gData. Maybe you get all the data when the app loads, and just respond to events as needed,\n        or maybe you mock everything because the API isn't available yet or you're testing. With Reactive Robot,\n        it's all the same.\n      </p>\n      <h5>Comparisons with Redux</h5>\n      <p>\n        Like Redux, ReactiveRobot has a specific way rerender in response to changes in state. Send an event. Unlike Redux,\n        there is no enforcement of how you make updates. You can decouple everything with a model that only responds to events,\n        or stick everything on gData. Also, unlike Redux, there is no embrace of immutability here. Use immutable objects\n        if you like, ReactiveRobot don't care. I'd say the main purpose of code is to mutate data - so don't be afraid to.\n        And unlike Redux where everybody gets access to a global Store, this is not a requirement in Reactive Robot.\n        If you have global data that needs to be cached, you have the gData object as a convenience.\n      </p>\n      <h5>Observations On Observing and Listening</h5>\n      <p>\n        Why are we using observers here instead of listeners? Because the visual metaphor is trendy right now. But seriously,\n        the audio metaphor is the same. You can be observing events or listening, same thing. Most of your basic intros\n        to rx based reactive systems will start teaching you about observables with the metaphor of listening to mouse activity\n        and thinking about it as a stream of data using listeners, aka observables. Because there is a similarity between\n        ReactiveRobot and rxjs, I've used \"next\" as the method name to indicate there is another event in the stream.\n        I could have used \"trigger\" but that seemed so...jQuery. We want to stay current, but recognize these issues have\n        a long history of multiple solutions. I am just trying to add another solution that has worked well for me, scales\n        easily, and encourages optimal performance with react.\n      </p>\n    </div>\n  );\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}