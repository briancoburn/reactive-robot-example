{"ast":null,"code":"var _jsxFileName = \"/Users/briancoburn/WebstormProjects/reactive_robot/src/App.js\";\nimport React, { useState, useEffect } from 'react';\nimport './App.css';\nimport * as ds from \"./DataService\";\nimport * as rr from './ReactiveRobot';\nimport * as ev from './Events';\nimport Component1 from \"./Component1\";\nimport Component2 from \"./Component2\";\n\nfunction App() {\n  const [hasRequestedData, setHasRequestedData] = useState(false); //if you're mounting/unmounting components, you can cache their data here\n  //do not put this in state, or you will rerender everything when it changes\n\n  let globalData = {\n    component1LatestValue: '',\n    component2LatestValue: ''\n  };\n  console.log('App==>rendering:');\n  useEffect(() => {\n    rr.addObserver(onEvent);\n  }, []);\n\n  function onEvent(event) {\n    switch (event.type) {\n      case ev.APP_TEST:\n        console.log('App==>got TEST_APP event');\n    }\n  }\n\n  function getData() {\n    console.log('App==>getData()');\n    ds.getData();\n    setHasRequestedData(true);\n  }\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"App\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 37,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"h4\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 38,\n      columnNumber: 7\n    }\n  }, \"Reactive Robot\"), /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 39,\n      columnNumber: 7\n    }\n  }, \"State management framework\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 40,\n      columnNumber: 7\n    }\n  }, \"ReactiveRobot is a lean and mean react state management framework that promotes a high level of decoupling, granular control of rendering, and components that react to events. It is intended to be a simple and highly performant alternative to popular state management systems such as Redux, mobx, useContext, etc.\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 45,\n      columnNumber: 7\n    }\n  }, \"You can examine the ReactiveRobot object yourself. It is quite simple. It has a list of observers, methods to add and remove them, and a trigger method, which will call the registered observer functions with any event that comes thru. There are not strict requirements for how to use ReactiveRobot, other than that you should use events to communicate changes in data. This example shows you some easy ways to get going. I'll call it best practices until I come up with or am made aware of better ones.\"), /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 52,\n      columnNumber: 7\n    }\n  }, \"What Do We Have Here?\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 53,\n      columnNumber: 7\n    }\n  }, \"This application was made with create-react-app. You might want to do that too. Aside from the files that are generated by create-react-app, these have been added to create a demonstration of how to use ReactiveRobot:\"), /*#__PURE__*/React.createElement(\"ul\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 57,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 58,\n      columnNumber: 9\n    }\n  }, \"ReactiveRobot\"), /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 59,\n      columnNumber: 9\n    }\n  }, \"Events\"), /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 60,\n      columnNumber: 9\n    }\n  }, \"DataService\"), /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 61,\n      columnNumber: 9\n    }\n  }, \"Component1\"), /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 62,\n      columnNumber: 9\n    }\n  }, \"Component2\")), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 64,\n      columnNumber: 7\n    }\n  }, \"ReactiveRobot itself, which adds/removes observers, and triggers events to them. Events is not required, but is a convenient way to store string constants for events that will give you code-completion in your IDE. DataService is not required, but would be where data comes from. Here I have it tightly coupled to App, but it could both observe requests for data, and send it off as events to interested components once it has been received (or mocked). Think of it as an object that will return events containing data. Two components, Component1 and Component2, have been added to demonstrate how lower level components listen for their own updates and rerender accordingly.\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 73,\n      columnNumber: 7\n    }\n  }, \"Because everything is an event in this framework there are no issues with async. You can use callbacks, promises, async await, sockets, mock data - ReactiveRobot don't care, it just sends the data as an event when it gets it. Of course you are responsible for pushing your observation of events as far down the component tree as possible. Components that want that data consume it, useState and rerender. Components that didn't register for that data never get that event and do not update, unless you mistakenly or purposely cause a rerender in one of their ancestors. This is the main purpose of this framework - to control unnecessary re-rendering. If you have developed large-scale react apps, you will recognize this is highly desirable for performance reasons.\"), /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 83,\n      columnNumber: 7\n    }\n  }, \"Example Application\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 84,\n      columnNumber: 7\n    }\n  }, \"Here we have two components, each which listens for its own custom event. When you click GET DATA, App calls the getData function on DataService, which in this case sets an interval and starts generating mock data which will randomly send update events to APP, COMPONENT1 and COMPONENT2. Logging has been added to allow you to see in the console what is rerendering on what events.\"), /*#__PURE__*/React.createElement(\"button\", {\n    disabled: hasRequestedData,\n    onClick: () => {\n      getData();\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 90,\n      columnNumber: 7\n    }\n  }, \"GET DATA\"), /*#__PURE__*/React.createElement(Component1, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 91,\n      columnNumber: 7\n    }\n  }), /*#__PURE__*/React.createElement(Component2, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 92,\n      columnNumber: 7\n    }\n  }), /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 93,\n      columnNumber: 7\n    }\n  }, \"Digging Deeper\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 94,\n      columnNumber: 7\n    }\n  }, \"Obviously, this is not a full-scale application. And there are some issues that will come up that aren't addressed in this example. If you don't have global state and you've pushed it all the way down the component tree to your leaf components, how do you maintain their state when they mount, unmount and remount again?\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 99,\n      columnNumber: 7\n    }\n  }, \"I see two simple ways to do this. First, maintain data that you might need again in a globaldata object (which is not state, and should never cause a rerender). I would put that object in App. App can listen for the event required to cache the data. In that case, you are duplicating your observation for the event in App and in the consuming Component. This is more boilerplate than I would like, but it is solid, and allows a great deal of flexibility if lots of different components that mount and unmount are sharing data. An alternative would be to use the useEffect unmount callback to send an event which App could consume that would cache the data when the component unmounted and provide as props when the component mounted again. But then your child component is coupled to your parent component (or App if that's the parent). You could do all of this with events rather than using props at all, but you might find such extreme decoupling demands more boilerplate than you want to write. With purity comes a price. With ReactiveRobot, you decide where you want to be on that spectrum.\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 113,\n      columnNumber: 7\n    }\n  }, \"Just remember, ReactiveRobot is short on rules and long on flexibility. You decide where you want to store data and initiate things like api calls. Obviously you could do an api call from a component when it mounts with useEffect, but you could also get data on the app level before the component mounts, because maybe you want your data to be uncoupled from you component lifecycle. Just set it up so when a component mounts, it sends an event requesting the data, the data is returned in a subsequent event, and the component does not know or care where that data came from. This gives you huge flexibility for mocking, testing and scaling.\"), /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 121,\n      columnNumber: 7\n    }\n  }, \"Why Not Props\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 122,\n      columnNumber: 7\n    }\n  }, \"Shouldn't I be using dumb components that just get props? Well, yes, if they really are dumb, that is, only displaying static data. Then you might as well pass props, display those, and you're done. But often, we want a component to load data, and also allow a user to change it, as in a pre-filled form that the user could update. If those properties are in props, and they need to be updated, then you are forced to update the parent to update the child, and potentially will cause unnecessary renders of siblings. For anything that could change, you generally want those to come in events, not props.\"), /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 130,\n      columnNumber: 7\n    }\n  }, \"Comparisons with Redux\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 131,\n      columnNumber: 7\n    }\n  }, \"Like Redux, ReactiveRobot has a specific way to update things. Send an event. Unlike Redux, there is no enforcement of this in the code, it is up to you to understand it and use it correctly. Also, unlike Redux, there is no embrace of immutability here. Use immutable objects if you like, ReactiveRobot don't care. I'd say the main purpose of code is to mutate data - so don't be afraid to. And unlike Redux where everybody gets access to a global Store, there is no such concept baked into ReactiveRobot. Ideally, components should not know or care where their data comes from.\"), /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 139,\n      columnNumber: 7\n    }\n  }, \"But Let's Say I'm Really Lazy\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 140,\n      columnNumber: 7\n    }\n  }, \"This seems like a lot of boilerplate just to not have global state. Isn't there an easier way? Sure. Pass your globalData object to everyone, but still use ReactiveRobot to let things know when an update is of concern to them. In this case, all of your components are coupled to your globalData object, but you still have the benefit that components are simply reacting to events, rather than updates on the globalData object itself. But now everyone has access to globalData, and you have lost the control and decoupling that you get from knowing that only events can update the data. Again, the choice is yours. ReactiveRobot is a tool to give you a range of options, from a lightly coupled, event based reactive system, where everyone can see a global object, to a highly decoupled event based reactive system, where you are enforcing that no object or component ever knows where it's data is coming from, or is able to update that data directly.\"));\n}\n\nexport default App;","map":{"version":3,"sources":["/Users/briancoburn/WebstormProjects/reactive_robot/src/App.js"],"names":["React","useState","useEffect","ds","rr","ev","Component1","Component2","App","hasRequestedData","setHasRequestedData","globalData","component1LatestValue","component2LatestValue","console","log","addObserver","onEvent","event","type","APP_TEST","getData"],"mappings":"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","sourcesContent":["import React, {useState, useEffect} from 'react'\nimport './App.css'\nimport * as ds from \"./DataService\"\nimport * as rr from './ReactiveRobot'\nimport * as ev from './Events'\nimport Component1 from \"./Component1\"\nimport Component2 from \"./Component2\"\n\nfunction App() {\n  const [hasRequestedData, setHasRequestedData] = useState(false)\n  //if you're mounting/unmounting components, you can cache their data here\n  //do not put this in state, or you will rerender everything when it changes\n  let globalData = {\n    component1LatestValue:'',\n    component2LatestValue:'',\n  }\n\n  console.log('App==>rendering:')\n\n  useEffect(()=>{\n    rr.addObserver(onEvent)\n  },[])\n\n  function onEvent(event){\n    switch (event.type){\n      case ev.APP_TEST:\n        console.log('App==>got TEST_APP event')\n    }\n  }\n  function getData(){\n    console.log('App==>getData()')\n    ds.getData()\n    setHasRequestedData(true)\n  }\n\n  return (\n    <div className=\"App\">\n      <h4>Reactive Robot</h4>\n      <h5>State management framework</h5>\n      <p>\n        ReactiveRobot is a lean and mean react state management framework that promotes a high level of decoupling,\n        granular control of rendering, and components that react to events. It is intended to be a simple and highly\n        performant alternative to popular state management systems such as Redux, mobx, useContext, etc.\n      </p>\n      <p>\n        You can examine the ReactiveRobot object yourself. It is quite simple. It has a list of observers, methods to\n        add and remove them, and a trigger method, which will call the registered observer functions with any event that\n        comes thru. There are not strict requirements for how to use ReactiveRobot, other than that you should use events\n        to communicate changes in data. This example shows you some easy ways to get going. I'll call it best practices\n        until I come up with or am made aware of better ones.\n      </p>\n      <h5>What Do We Have Here?</h5>\n      <p>\n        This application was made with create-react-app. You might want to do that too. Aside from the files that are generated\n        by create-react-app, these have been added to create a demonstration of how to use ReactiveRobot:\n      </p>\n      <ul>\n        <li>ReactiveRobot</li>\n        <li>Events</li>\n        <li>DataService</li>\n        <li>Component1</li>\n        <li>Component2</li>\n      </ul>\n      <p>\n        ReactiveRobot itself, which adds/removes observers, and triggers events to them. Events is not required,\n        but is a convenient way to store string constants for events that will give you code-completion in your IDE.\n        DataService is not required, but would be where data comes from. Here I have it tightly coupled to App,\n        but it could both observe requests for data, and send it off as events to interested components once it\n        has been received (or mocked). Think of it as an object that will return events containing data. Two\n        components, Component1 and Component2, have been added to demonstrate how lower level components listen\n        for their own updates and rerender accordingly.\n      </p>\n      <p>\n        Because everything is an event in this framework there are no issues with async. You can use callbacks,\n        promises, async await, sockets, mock data - ReactiveRobot don't care, it just sends the data as an event\n        when it gets it. Of course you are responsible for pushing your observation of events as far down the\n        component tree as possible. Components that want that data consume it, useState and rerender.\n        Components that didn't register for that data never get that event and do not update, unless you mistakenly\n        or purposely cause a rerender in one of their ancestors. This is the main purpose of this framework - to\n        control unnecessary re-rendering. If you have developed large-scale react apps, you will recognize this is\n        highly desirable for performance reasons.\n      </p>\n      <h5>Example Application</h5>\n      <p>\n        Here we have two components, each which listens for its own custom event. When you click GET DATA,\n        App calls the getData function on DataService, which in this case sets an interval and starts\n        generating mock data which will randomly send update events to APP, COMPONENT1 and COMPONENT2.\n        Logging has been added to allow you to see in the console what is rerendering on what events.\n      </p>\n      <button disabled={hasRequestedData} onClick={()=>{getData()}}>GET DATA</button>\n      <Component1/>\n      <Component2/>\n      <h5>Digging Deeper</h5>\n      <p>\n        Obviously, this is not a full-scale application. And there are some issues that will come up that aren't addressed\n        in this example. If you don't have global state and you've pushed it all the way down the component tree to your leaf\n        components, how do you maintain their state when they mount, unmount and remount again?\n      </p>\n      <p>\n        I see two simple ways to do this. First, maintain data that you might need again in a globaldata object\n        (which is not state, and should never cause a rerender). I would put that object in App. App can listen\n        for the event required to cache the data. In that case, you are duplicating your observation for the event\n        in App and in the consuming Component. This is more boilerplate than I would like, but it is solid, and\n        allows a great deal of flexibility if lots of different components that mount and unmount are sharing data.\n        An alternative would be to use the useEffect unmount callback to send an event which App could consume that\n        would cache the data when the component unmounted and provide as props when the component mounted again.\n        But then your child component is coupled to your parent component (or App if that's the parent).\n        You could do all of this with events rather than using props at all, but you might find such extreme\n        decoupling demands more boilerplate than you want to write. With purity comes a price. With ReactiveRobot,\n        you decide where you want to be on that spectrum.\n\n      </p>\n      <p>\n        Just remember, ReactiveRobot is short on rules and long on flexibility. You decide where you want to store\n        data and initiate things like api calls. Obviously you could do an api call from a component when it mounts with\n        useEffect, but you could also get data on the app level before the component mounts, because maybe you want\n        your data to be uncoupled from you component lifecycle. Just set it up so when a component mounts,\n        it sends an event requesting the data, the data is returned in a subsequent event, and the component does not\n        know or care where that data came from. This gives you huge flexibility for mocking, testing and scaling.\n      </p>\n      <h5>Why Not Props</h5>\n      <p>\n        Shouldn't I be using dumb components that just get props? Well, yes, if they really are dumb, that is, only\n        displaying static data. Then you might as well pass props, display those, and you're done. But often, we\n        want a component to load data, and also allow a user to change it, as in a pre-filled form that the user\n        could update. If those properties are in props, and they need to be updated, then you are forced to\n        update the parent to update the child, and potentially will cause unnecessary renders of siblings. For anything\n        that could change, you generally want those to come in events, not props.\n      </p>\n      <h5>Comparisons with Redux</h5>\n      <p>\n        Like Redux, ReactiveRobot has a specific way to update things. Send an event. Unlike Redux, there is no\n        enforcement of this in the code, it is up to you to understand it and use it correctly. Also, unlike Redux,\n        there is no embrace of immutability here. Use immutable objects if you like, ReactiveRobot don't care.\n        I'd say the main purpose of code is to mutate data - so don't be afraid to. And unlike Redux where everybody\n        gets access to a global Store, there is no such concept baked into ReactiveRobot. Ideally, components should\n        not know or care where their data comes from.\n      </p>\n      <h5>But Let's Say I'm Really Lazy</h5>\n      <p>\n        This seems like a lot of boilerplate just to not have global state. Isn't there an easier way? Sure. Pass your globalData\n        object to everyone, but still use ReactiveRobot to let things know when an update is of concern to them. In this case,\n        all of your components are coupled to your globalData object, but you still have the benefit that components are\n        simply reacting to events, rather than updates on the globalData object itself. But now everyone has access to globalData,\n        and you have lost the control and decoupling that you get from knowing that only events can update the data. Again, the\n        choice is yours. ReactiveRobot is a tool to give you a range of options, from a lightly coupled, event based reactive\n        system, where everyone can see a global object, to a highly decoupled event based reactive system, where you are\n        enforcing that no object or component ever knows where it's data is coming from, or is able to update that data directly.\n      </p>\n\n    </div>\n  );\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}