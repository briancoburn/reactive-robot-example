{"ast":null,"code":"var _jsxFileName = \"/Users/briancoburn/WebstormProjects/reactive_robot/src/App.js\";\nimport React, { useState, useEffect } from 'react';\nimport './App.css';\nimport * as ds from \"./DataService\";\nimport * as rr from './ReactiveRobot';\nimport * as ev from './Events';\nimport Component1 from \"./Component1\";\nimport Component2 from \"./Component2\";\n\nfunction App() {\n  const [hasRequestedData, setHasRequestedData] = useState(false); //if you're mounting/unmounting components, you can cache their data here\n  //do not put this in state, or you will rerender everything when it changes\n\n  let globalData = {\n    component1LatestValue: '',\n    component2LatestValue: ''\n  };\n  console.log('App==>rendering:');\n  useEffect(() => {\n    rr.addObserver(onEvent);\n  }, []);\n\n  function onEvent(event) {\n    switch (event.type) {\n      case ev.APP_TEST:\n        console.log('App==>got TEST_APP event');\n    }\n  }\n\n  function getData() {\n    console.log('App==>getData()');\n    ds.getData();\n    setHasRequestedData(true);\n  }\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"App\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 37,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"h4\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 38,\n      columnNumber: 7\n    }\n  }, \"Reactive Robot\"), /*#__PURE__*/React.createElement(\"h6\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 39,\n      columnNumber: 7\n    }\n  }, \"State management framework\"), `This is a simple, barebones example of how to use the ReactiveRobot state management framework.\n      ReactiveRobot is designed specifically to optimize rendering, and to give developers granular control\n      over the rendering process. While it can be convenient to implement a global data object, there is no \n      global state in a ReactiveRobot application. A ReactiveRobot application is as decoupled as you want, \n      and all updates are done via events. ReactiveRobot itself is really just an event bus, but there are\n      a few other parts that make it easier to work with. This application is an example a simple way to\n      create a highly decoupled and scalable application with ReactiveRobot. It has these parts:\n      \n      -ReactiveRobot - a pub/sub mechanism that pushes events to observers\n      -observers are objects or components that implement an onEvent method, which is registered with ReactiveRobot\n      -a way of pushing data into ReactiveRobot, say from an api. By convention, I'm calling this DataService\n      -Events object with string constants for frequently used events (not required, but convenient)\n      -a global data object to allow for caching\n      \n      By convention, I'm calling ReactiveRobot 'rr', Events constants are 'ev', and DataService is 'ds' - \n      we want to do as little typing as possible. Components might be any react visual components, which get their\n      data via events.\n      \n      by pushing your reactive events further down the component tree, you have granular control over rendering\n      This is exactly the opposite of relying on global state, such as in useContext.\n      `, /*#__PURE__*/React.createElement(\"button\", {\n    disabled: hasRequestedData,\n    onClick: () => {\n      getData();\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 61,\n      columnNumber: 7\n    }\n  }, \"GET DATA\"), /*#__PURE__*/React.createElement(Component1, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 62,\n      columnNumber: 7\n    }\n  }), /*#__PURE__*/React.createElement(Component2, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 63,\n      columnNumber: 7\n    }\n  }));\n}\n\nexport default App;","map":{"version":3,"sources":["/Users/briancoburn/WebstormProjects/reactive_robot/src/App.js"],"names":["React","useState","useEffect","ds","rr","ev","Component1","Component2","App","hasRequestedData","setHasRequestedData","globalData","component1LatestValue","component2LatestValue","console","log","addObserver","onEvent","event","type","APP_TEST","getData"],"mappings":";AAAA,OAAOA,KAAP,IAAeC,QAAf,EAAyBC,SAAzB,QAAyC,OAAzC;AACA,OAAO,WAAP;AACA,OAAO,KAAKC,EAAZ,MAAoB,eAApB;AACA,OAAO,KAAKC,EAAZ,MAAoB,iBAApB;AACA,OAAO,KAAKC,EAAZ,MAAoB,UAApB;AACA,OAAOC,UAAP,MAAuB,cAAvB;AACA,OAAOC,UAAP,MAAuB,cAAvB;;AAEA,SAASC,GAAT,GAAe;AACb,QAAM,CAACC,gBAAD,EAAmBC,mBAAnB,IAA0CT,QAAQ,CAAC,KAAD,CAAxD,CADa,CAEb;AACA;;AACA,MAAIU,UAAU,GAAG;AACfC,IAAAA,qBAAqB,EAAC,EADP;AAEfC,IAAAA,qBAAqB,EAAC;AAFP,GAAjB;AAKAC,EAAAA,OAAO,CAACC,GAAR,CAAY,kBAAZ;AAEAb,EAAAA,SAAS,CAAC,MAAI;AACZE,IAAAA,EAAE,CAACY,WAAH,CAAeC,OAAf;AACD,GAFQ,EAEP,EAFO,CAAT;;AAIA,WAASA,OAAT,CAAiBC,KAAjB,EAAuB;AACrB,YAAQA,KAAK,CAACC,IAAd;AACE,WAAKd,EAAE,CAACe,QAAR;AACEN,QAAAA,OAAO,CAACC,GAAR,CAAY,0BAAZ;AAFJ;AAID;;AACD,WAASM,OAAT,GAAkB;AAChBP,IAAAA,OAAO,CAACC,GAAR,CAAY,iBAAZ;AACAZ,IAAAA,EAAE,CAACkB,OAAH;AACAX,IAAAA,mBAAmB,CAAC,IAAD,CAAnB;AACD;;AAED,sBACE;AAAK,IAAA,SAAS,EAAC,KAAf;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBACE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,sBADF,eAEE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kCAFF,EAGI;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAvBI,eAwBE;AAAQ,IAAA,QAAQ,EAAED,gBAAlB;AAAoC,IAAA,OAAO,EAAE,MAAI;AAACY,MAAAA,OAAO;AAAG,KAA5D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,gBAxBF,eAyBE,oBAAC,UAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IAzBF,eA0BE,oBAAC,UAAD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,IA1BF,CADF;AA8BD;;AAED,eAAeb,GAAf","sourcesContent":["import React, {useState, useEffect} from 'react'\nimport './App.css'\nimport * as ds from \"./DataService\"\nimport * as rr from './ReactiveRobot'\nimport * as ev from './Events'\nimport Component1 from \"./Component1\"\nimport Component2 from \"./Component2\"\n\nfunction App() {\n  const [hasRequestedData, setHasRequestedData] = useState(false)\n  //if you're mounting/unmounting components, you can cache their data here\n  //do not put this in state, or you will rerender everything when it changes\n  let globalData = {\n    component1LatestValue:'',\n    component2LatestValue:'',\n  }\n\n  console.log('App==>rendering:')\n\n  useEffect(()=>{\n    rr.addObserver(onEvent)\n  },[])\n\n  function onEvent(event){\n    switch (event.type){\n      case ev.APP_TEST:\n        console.log('App==>got TEST_APP event')\n    }\n  }\n  function getData(){\n    console.log('App==>getData()')\n    ds.getData()\n    setHasRequestedData(true)\n  }\n\n  return (\n    <div className=\"App\">\n      <h4>Reactive Robot</h4>\n      <h6>State management framework</h6>\n      {`This is a simple, barebones example of how to use the ReactiveRobot state management framework.\n      ReactiveRobot is designed specifically to optimize rendering, and to give developers granular control\n      over the rendering process. While it can be convenient to implement a global data object, there is no \n      global state in a ReactiveRobot application. A ReactiveRobot application is as decoupled as you want, \n      and all updates are done via events. ReactiveRobot itself is really just an event bus, but there are\n      a few other parts that make it easier to work with. This application is an example a simple way to\n      create a highly decoupled and scalable application with ReactiveRobot. It has these parts:\n      \n      -ReactiveRobot - a pub/sub mechanism that pushes events to observers\n      -observers are objects or components that implement an onEvent method, which is registered with ReactiveRobot\n      -a way of pushing data into ReactiveRobot, say from an api. By convention, I'm calling this DataService\n      -Events object with string constants for frequently used events (not required, but convenient)\n      -a global data object to allow for caching\n      \n      By convention, I'm calling ReactiveRobot 'rr', Events constants are 'ev', and DataService is 'ds' - \n      we want to do as little typing as possible. Components might be any react visual components, which get their\n      data via events.\n      \n      by pushing your reactive events further down the component tree, you have granular control over rendering\n      This is exactly the opposite of relying on global state, such as in useContext.\n      `}\n      <button disabled={hasRequestedData} onClick={()=>{getData()}}>GET DATA</button>\n      <Component1/>\n      <Component2/>\n    </div>\n  );\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}