{"ast":null,"code":"var _jsxFileName = \"/Users/briancoburn/WebstormProjects/reactive_robot/src/App.js\";\nimport React, { useState, useEffect } from 'react';\nimport './App.css';\nimport * as ds from \"./DataService\";\nimport * as rr from './ReactiveRobot';\nimport * as ev from './Events';\nimport UIControls from \"./UIControls\";\nimport Component1 from \"./Component1\";\nimport Component2 from \"./Component2\";\n\nfunction App() {\n  //if you're mounting/unmounting components, you can cache their data here\n  //do not put this in state, or you will rerender everything when it changes\n  // let gData = {\n  //   component1LatestValue:'',\n  //   component2LatestValue:'',\n  // }\n  //console.log('App==>rendering==>rr.gData:',rr.gData)\n  //rr.gData = 'hello';//{...rr.gData, component1:{name:'component1'}}\n  console.log('App==>rendering==>rr.gData:', rr.gData);\n  useEffect(() => {\n    // rr.gData.component1 = {name:'Component1', createdAt: Date.now()}\n    // rr.gData.component2 = {name:'Component2', createdAt: Date.now()}\n    console.log('App==>adding myself as an observer');\n    rr.addObserver(onEvent);\n  }, []);\n\n  function onEvent(event) {\n    //console.log('App==>event:', event)\n    switch (event.type) {}\n  }\n\n  let numComponents = 300;\n  let components = [];\n\n  for (let i = 0; i < numComponents; i += 1) {\n    components.push( /*#__PURE__*/React.createElement(Component1, {\n      key: i,\n      name: 'Component' + i,\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 46,\n        columnNumber: 21\n      }\n    }));\n  }\n\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"App\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 51,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"h4\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 52,\n      columnNumber: 7\n    }\n  }, \"Reactive Robot\"), /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 53,\n      columnNumber: 7\n    }\n  }, \"State Management Framework For React\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 54,\n      columnNumber: 7\n    }\n  }, \"ReactiveRobot is a lean and mean react state management framework that promotes a high level of decoupling, granular control of rendering, and components that react to events. It is intended to be a simple, unopinionated, and highly performant alternative to popular state management systems such as Redux, mobx, useContext, etc. It is also sort of like rxjs without operators - a way of producing and consuming a stream of data in a network of decoupled objects using a pub/sub mechanism.\"), /*#__PURE__*/React.createElement(\"ul\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 61,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 62,\n      columnNumber: 9\n    }\n  }, \"Reactive Robot has two main rules:\"), /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 63,\n      columnNumber: 9\n    }\n  }, \"-do not observe or react directly to changes in global state\"), /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 64,\n      columnNumber: 9\n    }\n  }, \"-use only events to cause ui updates\")), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 66,\n      columnNumber: 7\n    }\n  }, \"If you follow these rules, Reactive Robot will allow you to create an application which is highly decoupled, scalable and performant. Because everything is an event, you have complete control over rendering and asynchronous operations.\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 71,\n      columnNumber: 7\n    }\n  }, \"You can examine the ReactiveRobot object yourself, ReactiveRobot.js. It is quite simple. It has a list of observers, methods to add and remove them, and a next method, which will call the registered observer functions with any event that comes thru. There is also a globalData, or gData property on the Reactive Robot object which can act as a cache for global data that you might want to reuse when loading/unloading views. There are not strict requirements for how to use ReactiveRobot, other than that you should use events to communicate changes in data, and those changes should be received by a registered onEvent function in components that want that data. This example shows you some easy ways to get going. I'll call it best practices until I come up with or am made aware of better ones.\"), /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 81,\n      columnNumber: 7\n    }\n  }, \"Example Application\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 82,\n      columnNumber: 7\n    }\n  }, \"This application was made with create-react-app. Aside from the files that are generated by create-react-app, these have been added to make a demonstration of how to use ReactiveRobot:\"), /*#__PURE__*/React.createElement(\"ul\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 86,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 87,\n      columnNumber: 9\n    }\n  }, \"ReactiveRobot.js\"), /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 88,\n      columnNumber: 9\n    }\n  }, \"Events.js\"), /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 89,\n      columnNumber: 9\n    }\n  }, \"DataService.js\"), /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 90,\n      columnNumber: 9\n    }\n  }, \"UIControls.js\"), /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 91,\n      columnNumber: 9\n    }\n  }, \"Component1.js\"), /*#__PURE__*/React.createElement(\"li\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 92,\n      columnNumber: 9\n    }\n  }, \"Component2.js\")), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 94,\n      columnNumber: 7\n    }\n  }, \"ReactiveRobot.js itself, which adds/removes observers, and sends events to them and keeps a data cache. Events.js is not required, but is a convenient way to store string constants for events that will give you code-completion in your IDE. DataService.js is not required, but would be where data is loaded or simulated. Here I have it tightly coupled to App, but it could both observe requests for data, and send them off as events to interested components once it has been received from api (or mocked). Think of it as an object that will generate events containing data. UIControls is included to show how a lower level component might produce events that result in the production of data that other components will consume. Because the GET_DATA event is completely decoupled from any concrete implementation, it could return the result of api calls, socket data, mock data, etc. Two components, Component1 and Component2, have been added to demonstrate how lower level components observe their own update events, COMPONENT1_TEST and COMPONENT2_TEST in this case, and rerender accordingly. Note that UIControls never rerenders here, because ReactiveRobot didn't send an event for that.\"), /*#__PURE__*/React.createElement(\"div\", {\n    className: 'ExampleSection',\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 109,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 110,\n      columnNumber: 9\n    }\n  }, \"Example Application\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 111,\n      columnNumber: 9\n    }\n  }, \"Here we have three components, UIControls, Component1 and Component2. UIControls sends an event to request the data. Component1 and Component2 are awaiting the result, each observing ReactiveRobot and waiting for its own custom event. When you click GET DATA, UIControls sends a GET_DATA event, which App receives, and then App calls the getData function on DataService, which in this case sets an interval and starts generating mock data which will randomly send update events to all of the observers. Logging has been added to allow you to see in the console what is rerendering on what events.\"), /*#__PURE__*/React.createElement(UIControls, {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 119,\n      columnNumber: 9\n    }\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    className: 'ComponentsContainer',\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 120,\n      columnNumber: 9\n    }\n  }, components)), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 125,\n      columnNumber: 7\n    }\n  }, \"Because everything is an event in this framework there are no issues with async. You can use callbacks, promises, async await, sockets, mock data - ReactiveRobot don't care, it just sends the data as an event when it gets it and the interested parties consume it. Of course you are responsible for pushing your observation of events to the appropriate level - usually as far down the component tree as possible. Components that want that data consume it, cache it, or useState and rerender. Components that didn't register for that data never process that event and do not update, unless you mistakenly or purposely cause a rerender in one of their ancestors. This is the main purpose of this framework - to control unnecessary re-rendering. If you have developed large-scale react apps, you will recognize this is highly desirable for performance reasons.\"), /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 137,\n      columnNumber: 7\n    }\n  }, \"Digging Deeper\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 138,\n      columnNumber: 7\n    }\n  }, \"Obviously, this is not a full-scale application. And there are some issues that will come up that aren't addressed in this example. If you don't have global state and you've pushed it all the way down the component tree to your leaf components, how do you maintain their state when they mount, unmount and remount again?\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 143,\n      columnNumber: 7\n    }\n  }, \"There are a couple of simple ways to do this. First, maintain data that you might need again in a gData object (which is not state, and should never cause a rerender). I would put that object in App. App can listen for the event required to cache the data. In that case, you are duplicating your observation for the event in App and in the consuming Component. This is more boilerplate than I would like, but it is solid, and allows a great deal of flexibility if lots of different components that mount and unmount are sharing data. An alternative would be to use the useEffect unmount callback to send an event which App could consume that would cache the data when the component unmounted and provide as props when the component mounted again. But then your child component is coupled to your parent component (or App if that's the parent). You could do all of this with events rather than using props at all, but you might find such extreme decoupling demands more boilerplate than you want to write. With purity comes a price. With ReactiveRobot, you decide where you want to be on that spectrum of decoupling. You may find that it is useful to use props in some cases and events in others.\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 158,\n      columnNumber: 7\n    }\n  }, \"Just remember, ReactiveRobot is short on rules and long on flexibility. You decide where you want to store data and initiate things like api calls. Obviously you could do an api call from a component when it mounts with useEffect, but you could also get data on the app level before the component mounts, because maybe you want your data to be uncoupled from your component lifecycle. Just set it up so app initialization requests data from an api and when a component mounts, it sends an event requesting the data, and if we already have that data locally the data is returned in a subsequent event. If not, we can request the data and return it in a subsequent event and the component does not know or care whether that data was cached locally, mocked, or return from an API request. This gives you huge flexibility for mocking, testing and scaling.\"), /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 168,\n      columnNumber: 7\n    }\n  }, \"Why Not Props\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 169,\n      columnNumber: 7\n    }\n  }, \"Shouldn't I be using dumb components that just get props? Well, yes, if they really are dumb, that is, only displaying static data. Then you might as well pass props, display those, and you're done. But often, we want a component to load data, and also allow a user to change it, as in a pre-filled form that the user could update. If those properties are in props, and they need to be updated, then you are forced to update the parent to update the child, and potentially will cause unnecessary renders of siblings. For anything that could change, you generally want those to come in events, not props.\"), /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 177,\n      columnNumber: 7\n    }\n  }, \"Comparisons with Redux\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 178,\n      columnNumber: 7\n    }\n  }, \"Like Redux, ReactiveRobot has a specific way to update things. Send an event. Unlike Redux, there is no enforcement of this in the code, it is up to you to understand it and use it correctly. Also, unlike Redux, there is no embrace of immutability here. Use immutable objects if you like, ReactiveRobot don't care. I'd say the main purpose of code is to mutate data - so don't be afraid to. And unlike Redux where everybody gets access to a global Store, there is no such concept baked into ReactiveRobot. Ideally, components should not know or care where their data comes from.\"), /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 186,\n      columnNumber: 7\n    }\n  }, \"But Let's Say I'm Really Lazy\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 187,\n      columnNumber: 7\n    }\n  }, \"This seems like a lot of boilerplate just to not have global state. Isn't there an easier way? Sure. Pass your gData object to everyone, but still use ReactiveRobot to let things know when an update is of concern to them. In this case, all of your components are coupled to your gData object, but you still have the benefit that components are simply reacting to events, rather than updates on the gData object itself. But be aware that because everyone has access to gData, you have lost the control and decoupling that you get from knowing that only events can update the data. The choice is yours. ReactiveRobot is a tool to give you a range of options, from a lightly coupled, event based reactive system, where everyone can see a global object, to a highly decoupled event based reactive system, where you are enforcing that no object or component ever knows where its data is coming from, or is able to update that data directly.\"), /*#__PURE__*/React.createElement(\"h5\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 198,\n      columnNumber: 7\n    }\n  }, \"Observations On Observing and Listening\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 199,\n      columnNumber: 7\n    }\n  }, \"Why are we using observers here instead of listeners? Because the visual metaphor is trendy right now. But seriously, the audio metaphor is the same. You can be observing events or listening, same thing. Most of your basic intros to rx based reactive systems will start teaching you about observables with the metaphor of listening to mouse activity and thinking about it as a stream of data using listeners, aka observables. Because there is a similarity between ReactiveRobot and rxjs, I've used \\\"next\\\" as the method name to indicate there is another event in the stream. I could have used \\\"trigger\\\" but that seemed so...jQuery. We want to stay current, but recognize these issues have a long history of multiple solutions. I am just trying to add another solution that has worked well for me, scales easily, and encourages optimal performance with react.\"));\n}\n\nexport default App;","map":{"version":3,"sources":["/Users/briancoburn/WebstormProjects/reactive_robot/src/App.js"],"names":["React","useState","useEffect","ds","rr","ev","UIControls","Component1","Component2","App","console","log","gData","addObserver","onEvent","event","type","numComponents","components","i","push"],"mappings":"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","sourcesContent":["import React, {useState, useEffect} from 'react'\nimport './App.css'\nimport * as ds from \"./DataService\"\nimport  * as rr from './ReactiveRobot'\nimport * as ev from './Events'\nimport UIControls from \"./UIControls\"\nimport Component1 from \"./Component1\"\nimport Component2 from \"./Component2\"\n\nfunction App() {\n\n  //if you're mounting/unmounting components, you can cache their data here\n  //do not put this in state, or you will rerender everything when it changes\n  // let gData = {\n  //   component1LatestValue:'',\n  //   component2LatestValue:'',\n  // }\n  //console.log('App==>rendering==>rr.gData:',rr.gData)\n  //rr.gData = 'hello';//{...rr.gData, component1:{name:'component1'}}\n\n  console.log('App==>rendering==>rr.gData:',rr.gData)\n\n  useEffect(()=>{\n    // rr.gData.component1 = {name:'Component1', createdAt: Date.now()}\n    // rr.gData.component2 = {name:'Component2', createdAt: Date.now()}\n    console.log('App==>adding myself as an observer')\n    rr.addObserver(onEvent)\n  },[])\n\n  function onEvent(event){\n    //console.log('App==>event:', event)\n    switch (event.type){\n      // case ev.GET_DATA:\n      //   console.log('App==>got GET_DATA event')\n      //   ds.getData()\n      //   break\n      // case ev.COMPONENT_UPDATE_GET:\n      //   console.log('App==>got COMPONENT_UPDATE_GET event')\n      //   ds.getData(event.data.name)\n    }\n  }\n\n  let numComponents = 300\n  let components = []\n  for(let i=0;i<numComponents;i+=1){\n    components.push(<Component1 key={i} name={'Component'+i}></Component1>)\n  }\n\n\n  return (\n    <div className=\"App\">\n      <h4>Reactive Robot</h4>\n      <h5>State Management Framework For React</h5>\n      <p>\n        ReactiveRobot is a lean and mean react state management framework that promotes a high level of decoupling,\n        granular control of rendering, and components that react to events. It is intended to be a simple, unopinionated,\n        and highly performant alternative to popular state management systems such as Redux, mobx, useContext, etc. It is also\n        sort of like rxjs without operators - a way of producing and consuming a stream of data in a network of decoupled objects\n        using a pub/sub mechanism.\n      </p>\n      <ul>\n        <li>Reactive Robot has two main rules:</li>\n        <li>-do not observe or react directly to changes in global state</li>\n        <li>-use only events to cause ui updates</li>\n      </ul>\n      <p>\n        If you follow these rules, Reactive Robot will allow you to create an application which is highly decoupled,\n        scalable and performant. Because everything is an event, you have complete control over rendering and\n        asynchronous operations.\n      </p>\n      <p>\n        You can examine the ReactiveRobot object yourself, ReactiveRobot.js. It is quite simple. It has a list of observers,\n        methods to add and remove them, and a next method, which will call the registered observer functions with any event\n        that comes thru. There is also a globalData, or gData property on the Reactive Robot object which can act as a cache\n        for global data that you might want to reuse when loading/unloading views.\n        There are not strict requirements for how to use ReactiveRobot, other than that you should use events\n        to communicate changes in data, and those changes should be received by a registered onEvent function in components\n        that want that data. This example shows you some easy ways to get going. I'll call it best practices until I come\n        up with or am made aware of better ones.\n      </p>\n      <h5>Example Application</h5>\n      <p>\n        This application was made with create-react-app. Aside from the files that are generated\n        by create-react-app, these have been added to make a demonstration of how to use ReactiveRobot:\n      </p>\n      <ul>\n        <li>ReactiveRobot.js</li>\n        <li>Events.js</li>\n        <li>DataService.js</li>\n        <li>UIControls.js</li>\n        <li>Component1.js</li>\n        <li>Component2.js</li>\n      </ul>\n      <p>\n        ReactiveRobot.js itself, which adds/removes observers, and sends events to them and keeps a data cache.\n        Events.js is not required, but is a convenient way to store string constants for events that will give you\n        code-completion in your IDE. DataService.js is not required, but would be where data is loaded or simulated.\n        Here I have it tightly coupled to App, but it could both observe requests for data, and send them off as events\n        to interested components once it has been received from api (or mocked). Think of it as an object that will\n        generate events containing data. UIControls is included to show how a lower level component might produce events\n        that result in the production\n        of data that other components will consume. Because the GET_DATA event is completely decoupled from any\n        concrete implementation, it could return the result of api calls, socket data, mock data, etc.\n        Two components, Component1 and Component2, have been added to demonstrate how lower level components observe\n        their own update events, COMPONENT1_TEST and COMPONENT2_TEST in this case, and rerender accordingly. Note that\n        UIControls never rerenders here, because ReactiveRobot didn't send an event for that.\n      </p>\n\n      <div className={'ExampleSection'}>\n        <h5>Example Application</h5>\n        <p>\n          Here we have three components, UIControls, Component1 and Component2. UIControls sends an event\n          to request the data. Component1 and Component2 are awaiting the result, each observing ReactiveRobot\n          and waiting for its own custom event. When you click GET DATA, UIControls sends a GET_DATA event, which App\n          receives, and then App calls the getData function on DataService, which in this case sets an interval and\n          starts generating mock data which will randomly send update events to all of the observers.\n          Logging has been added to allow you to see in the console what is rerendering on what events.\n        </p>\n        <UIControls/>\n        <div className={'ComponentsContainer'}>\n          {components}\n        </div>\n\n      </div>\n      <p>\n        Because everything is an event in this framework there are no issues with async. You can use callbacks,\n        promises, async await, sockets, mock data - ReactiveRobot don't care, it just sends the data as an event\n        when it gets it and the interested parties consume it. Of course you are responsible for pushing your\n        observation of events to the appropriate level - usually as far down the component tree as possible.\n        Components that want that data consume it, cache it, or useState and rerender. Components that didn't\n        register for that data never process that event and do not update, unless you mistakenly or purposely\n        cause a rerender in one of their ancestors. This is the main purpose of this framework - to control\n        unnecessary re-rendering. If you have developed large-scale react apps, you will recognize this is\n        highly desirable for performance reasons.\n      </p>\n\n      <h5>Digging Deeper</h5>\n      <p>\n        Obviously, this is not a full-scale application. And there are some issues that will come up that aren't addressed\n        in this example. If you don't have global state and you've pushed it all the way down the component tree to your leaf\n        components, how do you maintain their state when they mount, unmount and remount again?\n      </p>\n      <p>\n        There are a couple of simple ways to do this. First, maintain data that you might need again in a gData\n        object (which is not state, and should never cause a rerender). I would put that object in App. App can listen\n        for the event required to cache the data. In that case, you are duplicating your observation for the event\n        in App and in the consuming Component. This is more boilerplate than I would like, but it is solid, and\n        allows a great deal of flexibility if lots of different components that mount and unmount are sharing data.\n        An alternative would be to use the useEffect unmount callback to send an event which App could consume that\n        would cache the data when the component unmounted and provide as props when the component mounted again.\n        But then your child component is coupled to your parent component (or App if that's the parent).\n        You could do all of this with events rather than using props at all, but you might find such extreme\n        decoupling demands more boilerplate than you want to write. With purity comes a price. With ReactiveRobot,\n        you decide where you want to be on that spectrum of decoupling. You may find that it is useful to use props\n        in some cases and events in others.\n\n      </p>\n      <p>\n        Just remember, ReactiveRobot is short on rules and long on flexibility. You decide where you want to store\n        data and initiate things like api calls. Obviously you could do an api call from a component when it mounts with\n        useEffect, but you could also get data on the app level before the component mounts, because maybe you want\n        your data to be uncoupled from your component lifecycle. Just set it up so app initialization requests data\n        from an api and when a component mounts, it sends an event requesting the data, and if we already have that data\n        locally the data is returned in a subsequent event. If not, we can request the data and return it in a subsequent\n        event and the component does not know or care whether that data was cached locally, mocked, or return from an API\n        request. This gives you huge flexibility for mocking, testing and scaling.\n      </p>\n      <h5>Why Not Props</h5>\n      <p>\n        Shouldn't I be using dumb components that just get props? Well, yes, if they really are dumb, that is, only\n        displaying static data. Then you might as well pass props, display those, and you're done. But often, we\n        want a component to load data, and also allow a user to change it, as in a pre-filled form that the user\n        could update. If those properties are in props, and they need to be updated, then you are forced to\n        update the parent to update the child, and potentially will cause unnecessary renders of siblings. For anything\n        that could change, you generally want those to come in events, not props.\n      </p>\n      <h5>Comparisons with Redux</h5>\n      <p>\n        Like Redux, ReactiveRobot has a specific way to update things. Send an event. Unlike Redux, there is no\n        enforcement of this in the code, it is up to you to understand it and use it correctly. Also, unlike Redux,\n        there is no embrace of immutability here. Use immutable objects if you like, ReactiveRobot don't care.\n        I'd say the main purpose of code is to mutate data - so don't be afraid to. And unlike Redux where everybody\n        gets access to a global Store, there is no such concept baked into ReactiveRobot. Ideally, components should\n        not know or care where their data comes from.\n      </p>\n      <h5>But Let's Say I'm Really Lazy</h5>\n      <p>\n        This seems like a lot of boilerplate just to not have global state. Isn't there an easier way? Sure. Pass your gData\n        object to everyone, but still use ReactiveRobot to let things know when an update is of concern to them. In this case,\n        all of your components are coupled to your gData object, but you still have the benefit that components are\n        simply reacting to events, rather than updates on the gData object itself. But be aware that because everyone has\n        access to gData, you have lost the control and decoupling that you get from knowing that only events can update\n        the data. The choice is yours. ReactiveRobot is a tool to give you a range of options, from a lightly coupled,\n        event based reactive system, where everyone can see a global object, to a highly decoupled event based reactive system,\n        where you are enforcing that no object or component ever knows where its data is coming from, or is able to update that\n        data directly.\n      </p>\n      <h5>Observations On Observing and Listening</h5>\n      <p>\n        Why are we using observers here instead of listeners? Because the visual metaphor is trendy right now. But seriously,\n        the audio metaphor is the same. You can be observing events or listening, same thing. Most of your basic intros\n        to rx based reactive systems will start teaching you about observables with the metaphor of listening to mouse activity\n        and thinking about it as a stream of data using listeners, aka observables. Because there is a similarity between\n        ReactiveRobot and rxjs, I've used \"next\" as the method name to indicate there is another event in the stream.\n        I could have used \"trigger\" but that seemed so...jQuery. We want to stay current, but recognize these issues have\n        a long history of multiple solutions. I am just trying to add another solution that has worked well for me, scales\n        easily, and encourages optimal performance with react.\n      </p>\n    </div>\n  );\n}\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}